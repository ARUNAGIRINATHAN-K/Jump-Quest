<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTML Canvas Platformer</title>
<style>
  :root {
    --bg: #1b1f2a;
    --ui: #ffffff;
    --accent: #2ecc71;
    --danger: #e74c3c;
    --coin: #f1c40f;
    --sky: linear-gradient(#7ec0ee, #bde3ff);
    --ground: #8b5a2b;
    --platform: #654321;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: var(--ui);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  .wrap {
    display: grid;
    place-items: center;
    height: 100%;
    gap: 12px;
    padding: 12px;
  }
  canvas {
    background: var(--sky);
    border: 2px solid #10131a;
    border-radius: 8px;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
  }
  .hud {
    max-width: 800px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    font-weight: 600;
  }
  .hud .left, .hud .right {
    display: flex;
    gap: 16px;
    align-items: center;
  }
  .pill {
    padding: 6px 10px;
    border: 1px solid #263042;
    border-radius: 999px;
    background: #0f1320;
    font-size: 14px;
  }
  .kbd {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    background: #0b0f18;
    border: 1px solid #1f2a40;
    padding: 2px 6px;
    border-radius: 6px;
  }
  .footer {
    opacity: 0.8;
    font-size: 13px;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <span class="pill">Move: <span class="kbd">← / →</span> or <span class="kbd">A / D</span></span>
        <span class="pill">Jump: <span class="kbd">Space</span> / <span class="kbd">W</span> / <span class="kbd">↑</span></span>
        <span class="pill">Reset: <span class="kbd">R</span></span>
      </div>
      <div class="right">
        <span id="coins" class="pill">Coins: 0</span>
        <span id="status" class="pill">Ready</span>
      </div>
    </div>
    <canvas id="game" width="960" height="540" aria-label="Platformer game"></canvas>
    <div class="footer">Reach the flag. Collect all coins for a perfect run.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // World and camera
  const TILE = 64;
  const WORLD = {
    width: 64 * TILE,  // 4096px
    height: canvas.height,
    gravity: 2000,     // px/s^2
    airFriction: 0.92,
    groundFriction: 0.8,
    maxRunSpeed: 380,
    accel: 1800,
    jumpVel: 820,
    maxJumpHoldMs: 150,
  };

  const camera = { x: 0, y: 0, lerp: 0.16 };

  // Input
  const keys = new Set();
  let jumpHeld = false;

  // Entities
  const player = {
    x: 80, y: 0, w: 42, h: 56,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    alive: true,
    coins: 0,
  };

  const platforms = [];
  const coins = [];
  const enemies = [];
  let flag = { x: WORLD.width - TILE * 1.5, y: 0, w: 24, h: TILE * 3 };

  // Level generation
  function addPlatform(x, y, w, h=TILE/2) { platforms.push({ x, y, w, h }); }
  function addEnemy(x, y, w=44, h=40, range=TILE*3, speed=120) {
    enemies.push({ x, y, w, h, baseX: x, range, dir: 1, speed, alive: true });
  }
  function addCoin(x, y, r=10) { coins.push({ x, y, r, taken: false, hover: Math.random()*Math.PI*2 }); }

  function buildLevel() {
    platforms.length = 0; coins.length = 0; enemies.length = 0;

    // Ground segments
    for (let i = 0; i < WORLD.width; i += TILE * 4) {
      addPlatform(i, canvas.height - TILE, TILE * 4, TILE);
    }

    // Stairs and floating platforms
    addPlatform(TILE*6, canvas.height - TILE*2, TILE*2);
    addPlatform(TILE*8, canvas.height - TILE*3, TILE*2);
    addPlatform(TILE*10, canvas.height - TILE*4, TILE*2);

    addPlatform(TILE*14, canvas.height - TILE*3.5, TILE*3);
    addPlatform(TILE*18.5, canvas.height - TILE*5, TILE*2);
    addPlatform(TILE*21, canvas.height - TILE*4.5, TILE*2);
    addPlatform(TILE*24, canvas.height - TILE*3.2, TILE*3);

    // Long run with gaps
    addPlatform(TILE*28, canvas.height - TILE*2.2, TILE*2);
    addPlatform(TILE*31.2, canvas.height - TILE*3.5, TILE*2);
    addPlatform(TILE*34.5, canvas.height - TILE*2.2, TILE*2);
    addPlatform(TILE*37.7, canvas.height - TILE*3.5, TILE*2);

    // Final approach
    addPlatform(TILE*42, canvas.height - TILE*2.5, TILE*3);
    addPlatform(TILE*46, canvas.height - TILE*3.2, TILE*2);
    addPlatform(TILE*49, canvas.height - TILE*2.2, TILE*3);

    // Coins
    [7, 8, 9, 14.5, 18.5, 21.2, 24.8, 31.6, 34.9, 38.1, 46.4, 50.2].forEach((t, i) => {
      addCoin(TILE * t + (i % 2 === 0 ? 0 : 12), canvas.height - TILE*3 - (i % 3) * 22);
    });

    // Enemies patrolling platforms
    addEnemy(TILE*15, canvas.height - TILE*4.5 - 40);
    addEnemy(TILE*25.2, canvas.height - TILE*3.2 - 40, 44, 40, TILE*2.5, 140);
    addEnemy(TILE*33, canvas.height - TILE*3.5 - 40, 44, 40, TILE*2.8, 110);
    addEnemy(TILE*48, canvas.height - TILE*3.2 - 40, 44, 40, TILE*2.2, 100);
  }

  function resetGame() {
    player.x = 80;
    player.y = 0;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    player.facing = 1;
    player.alive = true;
    player.coins = 0;
    flag = { x: WORLD.width - TILE * 1.5, y: 0, w: 24, h: TILE * 3 };
    buildLevel();
    setStatus('Ready');
    updateHud();
  }

  // Collision helpers
  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  // Rendering
  function drawBackground(camX) {
    // Parallax layers
    ctx.fillStyle = '#bde3ff';
    ctx.fillRect(camX - canvas.width, 0, WORLD.width + canvas.width, canvas.height);

    // Hills (parallax)
    ctx.save();
    ctx.translate(-camX * 0.2, 0);
    ctx.fillStyle = '#a6d6f5';
    for (let i = -2; i < WORLD.width / (TILE*3); i++) {
      const hx = i * TILE * 3;
      const hy = canvas.height - TILE * 1.2;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      ctx.quadraticCurveTo(hx + TILE*1.5, hy - TILE, hx + TILE*3, hy);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // Clouds
    ctx.save();
    ctx.translate(-camX * 0.4, 0);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for (let i = 0; i < 24; i++) {
      const cx = i * TILE * 2.5 + (i%3)*20;
      const cy = 60 + (i%5)*18;
      ctx.beginPath();
      ctx.arc(cx, cy, 16, 0, Math.PI*2);
      ctx.arc(cx+22, cy+4, 18, 0, Math.PI*2);
      ctx.arc(cx+44, cy, 16, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawPlatforms() {
    ctx.fillStyle = '#5a3a1f';
    platforms.forEach(p => {
      // top surface
      ctx.fillRect(p.x, p.y, p.w, p.h);
      // bevel
      ctx.fillStyle = '#734828';
      ctx.fillRect(p.x, p.y, p.w, 6);
      ctx.fillStyle = '#5a3a1f';
    });

    // Ground grass
    ctx.fillStyle = '#2ecc71';
    platforms.forEach(p => {
      ctx.fillRect(p.x, p.y - 4, p.w, 4);
    });
  }

  function drawPlayer() {
    // Body
    ctx.fillStyle = '#1f6feb';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    // Face
    ctx.fillStyle = '#ffe0b2';
    ctx.fillRect(player.x + 10, player.y + 10, 22, 18);
    // Eye
    ctx.fillStyle = '#111';
    ctx.fillRect(player.x + (player.facing > 0 ? 28 : 12), player.y + 16, 4, 4);
    // Hat
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(player.x + 6, player.y + 6, 30, 8);
  }

  function drawEnemies() {
    enemies.forEach(e => {
      if (!e.alive) return;
      ctx.fillStyle = '#8e44ad';
      ctx.fillRect(e.x, e.y, e.w, e.h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(e.x + 8, e.y + 10, 8, 6);
      ctx.fillRect(e.x + e.w - 16, e.y + 10, 8, 6);
    });
  }

  function drawCoins(dt) {
    coins.forEach(c => {
      if (c.taken) return;
      c.hover += dt * 0.006; // subtle bobbing
      const bob = Math.sin(c.hover) * 3;
      ctx.save();
      ctx.translate(0, bob);
      // coin
      ctx.fillStyle = '#f1c40f';
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d4ac0d';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r - 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawFlag() {
    // Pole
    ctx.fillStyle = '#c0c6d8';
    ctx.fillRect(flag.x, canvas.height - TILE*3, 6, TILE*3);
    // Base
    ctx.fillStyle = '#8892a6';
    ctx.fillRect(flag.x - 8, canvas.height - TILE, 22, 8);
    // Flag
    ctx.fillStyle = '#2ecc71';
    ctx.beginPath();
    ctx.moveTo(flag.x + 6, canvas.height - TILE*3 + 16);
    ctx.lineTo(flag.x + 6 + 36, canvas.height - TILE*3 + 26);
    ctx.lineTo(flag.x + 6, canvas.height - TILE*3 + 36);
    ctx.closePath();
    ctx.fill();
  }

  // Physics and game logic
  let lastTime = performance.now();

  function step(now) {
    const dt = Math.min(32, now - lastTime); // ms cap to avoid huge step
    lastTime = now;
    const dtSec = dt / 1000;

    handleInput(dtSec);
    physics(dtSec);
    updateCamera(dtSec);
    checkCollisions(dtSec);

    // Render
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    drawBackground(camera.x);
    drawPlatforms();
    drawCoins(dt);
    drawEnemies();
    drawFlag();
    drawPlayer();
    ctx.restore();

    requestAnimationFrame(step);
  }

  function handleInput(dt) {
    if (!player.alive) return;
    const left = keys.has('ArrowLeft') || keys.has('KeyA');
    const right = keys.has('ArrowRight') || keys.has('KeyD');

    player.facing = right ? 1 : (left ? -1 : player.facing);

    if (left && !right) {
      player.vx -= WORLD.accel * dt;
    } else if (right && !left) {
      player.vx += WORLD.accel * dt;
    } else {
      // friction
      player.vx *= player.onGround ? WORLD.groundFriction : WORLD.airFriction;
      if (Math.abs(player.vx) < 0.001) player.vx = 0;
    }

    player.vx = Math.max(-WORLD.maxRunSpeed, Math.min(WORLD.maxRunSpeed, player.vx));
  }

  let jumpStartTime = null;
  function tryJump() {
    if (player.onGround && player.alive) {
      player.vy = -WORLD.jumpVel;
      player.onGround = false;
      jumpHeld = true;
      jumpStartTime = performance.now();
    }
  }
  function releaseJump() {
    jumpHeld = false;
  }

  function physics(dt) {
    // Variable jump height: cut gravity slightly while jump key is held early
    const isJumpBoost =
      jumpHeld && jumpStartTime && (performance.now() - jumpStartTime) < WORLD.maxJumpHoldMs;

    const gravity = isJumpBoost ? WORLD.gravity * 0.7 : WORLD.gravity;

    player.vy += gravity * dt;

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // World bounds horizontally
    player.x = Math.max(0, Math.min(WORLD.width - player.w, player.x));

    // Death: fall off screen
    if (player.y > canvas.height + 300) {
      player.alive = false;
      setStatus('You fell. Press R to retry.');
    }
  }

  function checkCollisions(dt) {
    // Platform collisions (AABB)
    player.onGround = false;
    platforms.forEach(p => {
      const a = { x: player.x, y: player.y, w: player.w, h: player.h };
      const b = p;
      if (!rectsOverlap(a, b)) return;

      const prevY = player.y - player.vy * dt;
      const prevX = player.x - player.vx * dt;

      const overlapBottom = prevY + player.h <= b.y && player.y + player.h > b.y;
      const overlapTop = prevY >= b.y + b.h && player.y < b.y + b.h;
      const overlapLeft = prevX + player.w <= b.x && player.x + player.w > b.x;
      const overlapRight = prevX >= b.x + b.w && player.x < b.x + b.w;

      if (overlapBottom) {
        // Land on top
        player.y = b.y - player.h;
        player.vy = 0;
        player.onGround = true;
        jumpStartTime = null;
      } else if (overlapTop) {
        // Hit from below
        player.y = b.y + b.h;
        player.vy = 0;
      } else if (overlapLeft) {
        player.x = b.x - player.w;
        player.vx = Math.min(player.vx, 0);
      } else if (overlapRight) {
        player.x = b.x + b.w;
        player.vx = Math.max(player.vx, 0);
      }
    });

    // Coins pickup
    coins.forEach(c => {
      if (c.taken) return;
      const px = player.x + player.w/2;
      const py = player.y + player.h/2;
      const dx = px - c.x;
      const dy = py - c.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 < (player.w*0.5 + c.r) * (player.w*0.5 + c.r)) {
        c.taken = true;
        player.coins++;
        updateHud();
      }
    });

    // Enemy collisions and movement
    enemies.forEach(e => {
      if (!e.alive) return;

      // Patrol motion
      e.x += e.dir * e.speed * dt;
      if (e.x > e.baseX + e.range) { e.x = e.baseX + e.range; e.dir = -1; }
      if (e.x < e.baseX - e.range) { e.x = e.baseX - e.range; e.dir = 1; }

      // Check collision with player
      if (rectsOverlap({x: player.x, y: player.y, w: player.w, h: player.h}, e)) {
        // If player is falling onto enemy: stomp
        const falling = player.vy > 120;
        const above = player.y + player.h <= e.y + e.h * 0.4;
        if (falling && above) {
          e.alive = false;
          player.vy = -WORLD.jumpVel * 0.6;
        } else {
          // Hurt player
          player.alive = false;
          setStatus('Ouch! Press R to retry.');
        }
      }
    });

    // Flag reach
    const flagRect = { x: flag.x, y: canvas.height - TILE*3, w: flag.w, h: TILE*3 };
    if (rectsOverlap({x: player.x, y: player.y, w: player.w, h: player.h}, flagRect) && player.alive) {
      const allCoins = coins.every(c => c.taken);
      setStatus(allCoins ? 'Perfect! All coins collected!' : 'You made it! (Try for all coins)');
      player.alive = false;
    }
  }

  function updateCamera(dt) {
    const targetX = Math.max(0, Math.min(WORLD.width - canvas.width, player.x + player.w/2 - canvas.width/2));
    camera.x += (targetX - camera.x) * camera.lerp;
    camera.y = 0;
  }

  // HUD
  const coinsEl = document.getElementById('coins');
  const statusEl = document.getElementById('status');
  function updateHud() {
    coinsEl.textContent = `Coins: ${player.coins}`;
  }
  function setStatus(text) {
    statusEl.textContent = text;
  }

  // Input handlers
  window.addEventListener('keydown', (e) => {
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (['Space', 'ArrowUp', 'KeyW'].includes(e.code)) tryJump();
    if (e.code === 'KeyR') resetGame();
  });
  window.addEventListener('keyup', (e) => {
    keys.delete(e.code);
    if (['Space', 'ArrowUp', 'KeyW'].includes(e.code)) releaseJump();
  });

  // Init
  resetGame();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>